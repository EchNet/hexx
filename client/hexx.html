<html>
<head>
<title>Hex Drag and Drop</title>
<style>
canvas.palette {
	cursor: pointer;
	margin: 10px;
}
div.canvas {
	position: relative;
	margin: 40px;
}
div.canvas > canvas {
	position: absolute;
	top: 0px;
}
canvas.drawing {
	border: solid 1px #ddd;
	background-color: #eee;
}
</style>
</head>
<body>
<div id="palette"></div>
<div id="canvas" class="canvas">
	<canvas id="drawing-canvas" class="drawing" width="800" height="300"></canvas>
	<canvas id="overlay-canvas" class="overlay" width="800" height="300"></canvas>
</div>
</body>
<script src="js/lib/jquery-3.1.1.slim.min.js"></script>
<script>

	var config = {
		palette: {
			elementRadius: 40
		},
		canvas: {
			width: 800,
			height: 300, 
			elementRadius: 40,
			lineStyle: "rgba(150,150,150,0.5)",
			lineWidth: 2
		}
	};

	var data = {
		palette: {
			id: 0,
			name: "palette0",
			contents: [
				{
					id: 1,
					name: "who?",
					image: {
						url: "img/usr-cre.png"
					}
				},
				{
					id: 2,
					name: "red",
					fill: "rgba(255,0,0,1)"
				},
				{
					id: 3,
					name: "blue",
					fill: "rgba(0,0,255,1)"
				},
				{
					id: 4,
					name: "yellow",
					fill: "rgba(240,240,0,1)"
				}
			]
		},
		canvas: {
			id: 47,
			name: "rich",
			contents: []
		}
	};

	function withElement(id, func) {
		var ele = document.getElementById(id);
		return func(ele);
	}

	function withContext(canvas, func) {
		var context = canvas.getContext("2d");
		return func(context, canvas);
	}

	function forEach(array, func) {
		for (var i in array) {
			func(array[i], i);
		}
	}

	function traceRegularHexagon(context, x, y, radius, angle) {
		x += Math.cos(angle) * radius;
		y += Math.sin(angle) * radius;
		angle += 2*Math.PI/3;

    context.beginPath();
		context.moveTo(x, y);
		for (var i = 0; i < 6; ++i) {
			x += Math.cos(angle) * radius;
			y += Math.sin(angle) * radius;
			context.lineTo(x, y);
			angle += Math.PI/3;
		}
    context.closePath();    
	}

	function drawRegularHexagon(context, options) {
		options = options || { strokeStyle: "rgba(0,0,0,1)" };
		var radius = options.radius || 100;
		var x = options.x != null ? options.x : radius;
		var y = options.y != null ? options.y : radius;
		var angle = options.angle != null ? (options.angle * Math.PI/180) : 0;

		context.save();
		traceRegularHexagon(context, x, y, radius, angle);
    context.clip();
		if (options.fillStyle) {
			context.fillStyle = options.fillStyle;
			context.fillRect(x - radius, y - radius, radius*2, radius*2);
		}
		else {
			context.clearRect(x - radius, y - radius, radius*2, radius*2);
		}
		if (options.image) {
			context.drawImage(options.image, x - radius, y - radius, radius*2, radius*2);
		}
		context.restore();
		if (options.strokeStyle) {
			context.strokeStyle = options.strokeStyle;
			if (options.lineWidth) {
				context.lineWidth = options.lineWidth;
			}
			context.stroke();
		}
	}

	function loadImage(url) {
		var promise = $.Deferred();
		var img = new Image();
		img.onload = function() { 
			promise.resolve(img);
		};
		img.onerror = function(error) {
			promise.reject(error);
		}
		img.crossOrigin = "anonymous";
		img.src = url;
		return promise;
	}

	function clearCanvas(canvas) {
		withContext(canvas, function(context) {
			context.clearRect(0, 0, canvas.width, canvas.height);
		});
	}

	function round(n) {
		return Math.floor(n + 0.5);
	}

	function closestHex(e) {
		var radius = config.canvas.elementRadius;
		var canvasWidth = config.canvas.width;
		var canvasHeight = config.canvas.height;
		var rowOffset = radius * Math.sqrt(3);
		var columnOffset = radius * Math.sqrt(2);

		var x = e.offsetX;
		var y = e.offsetY;

		var best = {};

		var centerX = -rowOffset;
		for (var col = -1; centerX < canvasWidth + columnOffset; ++col) {
			var centerY = (col % 2) * rowOffset/2;
			while (centerY < canvasHeight + rowOffset) {
				var dsq = (centerX-x)*(centerX-x) + (centerY-y)*(centerY-y);
				if (best.dsq == null || dsq < best.dsq) {
					best.dsq = dsq;
					best.centerX = centerX;
					best.centerY = centerY;
				}
				centerY += rowOffset;
			}
			centerX += columnOffset;
		}

		if (best.centerX != null && best.centerX >= 0 && best.centerX < canvasWidth &&
			best.centerY >= 0 && best.centerY < canvasHeight) {
			return {
				x: best.centerX, y: best.centerY
			}
		}
	}

	function showFeedback(canvas, e) {
		clearCanvas(canvas);
		var center = closestHex(e);
		if (center) {
			withContext(canvas, function(context) {
				drawRegularHexagon(context, {
					radius: config.canvas.elementRadius,
					x: center.x,
					y: center.y,
					lineWidth: config.canvas.lineWidth,
					strokeStyle: config.canvas.lineStyle
				});
			});
			return center;
		}
	}

	function handleDragStart(e) {
	  this.style.opacity = "0.4";
		e.dataTransfer.effectAllowed = "copy";
		e.dataTransfer.setData("text/plain", this.dataset.paletteIndex);
	}

	function handleDragOver(e) {
		e.preventDefault && e.preventDefault();
		if (showFeedback(this, e)) {
			e.dataTransfer.dropEffect = "copy";
		}
		return false;
	}

	function handleDragEnter(e) {
		showFeedback(this, e);
	}

	function handleDragLeave(e) {
		clearCanvas(this);
	}

	function handleDragEnd(e) {
	  this.style.opacity = "1";
	}

	function getDraggedPaletteEntry(e) {
		var pIndex = e.dataTransfer.getData("text/plain");
		var pEntry = data.palette.contents[pIndex];
		return pEntry;
	}

	function addToCanvas(pEntry, center) {
		var options = {
			radius: config.canvas.elementRadius,
			x: center.x,
			y: center.y,
			fillStyle: pEntry.fill,
			lineWidth: config.canvas.lineWidth,
			strokeStyle: config.canvas.lineStyle
		}
		if (pEntry.image) {
			if (pEntry.image.obj) {
				options.image = pEntry.image.obj;
			}
			else {
				options.fillStyle = "rgba(0,0,0,1)";
			}
		}
		data.canvas.contents.push(options);
		return data.canvas.contents.length - 1;
	}

	function drawCanvasEntry(cIndex) {
		var cEntry = data.canvas.contents[cIndex];
		withElement("drawing-canvas", function(canvas) {
			withContext(canvas, function(context) {
				drawRegularHexagon(context, cEntry);
			});
		});
	}

	function handleDrop(e) {
		e.stopPropagation && e.stopPropagation();
		clearCanvas(this);
		var center = closestHex(e);
		if (center) {
			var cIndex = addToCanvas(getDraggedPaletteEntry(e), center);
			drawCanvasEntry(cIndex);
		}
		return false;
	}

	function initCanvas() {
		return $.Deferred().resolve();
	}

	function enableCanvas() {
		withElement("overlay-canvas", function(canvas) {
			canvas.addEventListener("dragenter", handleDragEnter, false);
			canvas.addEventListener("dragover", handleDragOver, false);
			canvas.addEventListener("dragleave", handleDragLeave, false);
			canvas.addEventListener("drop", handleDrop, false);
		});
	}

	function initPalette() {
		var promise = $.Deferred();
		var imageLoadCount = 0;
		var loadsStarted = false;
		withElement("palette", function(palette) {
			forEach(data.palette.contents, function(pEntry, pIndex) {
				var ele = document.createElement("canvas");
				ele.draggable = true;
				ele.width = ele.height = config.palette.elementRadius * 2;
				ele.dataset.paletteIndex = pIndex;
				ele.className = "palette";
				palette.appendChild(ele);
				pEntry.ele = ele;
				if (pEntry.image) {
					imageLoadCount += 1;
					loadImage(pEntry.image.url).then(function(img) {
						pEntry.image.obj = img;
						imageLoadCount -= 1;
						if (loadsStarted && imageLoadCount == 0) {
							promise.resolve();
						}
					});
				}
			});
		});
		if (imageLoadCount == 0) {
			promise.resolve();
		}
		else {
			loadsStarted = true;
		}
		return promise;
	}

	function renderCanvas() {
	}

	function renderPalette() {
		forEach(data.palette.contents, function(pEntry) {
			var hexConfig = {
				radius: config.palette.elementRadius,
			}
			if (pEntry.image) {
				hexConfig.image = pEntry.image.obj;
			}
			else {
				hexConfig.fillStyle = pEntry.fill;
			}
			withContext(pEntry.ele, function(context) {
				drawRegularHexagon(context, hexConfig);
			});
		});
	}

	function enablePalette() {
		forEach(data.palette.contents, function(pEntry) {
			pEntry.ele.addEventListener("dragstart", handleDragStart, false);
			pEntry.ele.addEventListener("dragend", handleDragEnd, false);
			pEntry.ele.addEventListener("drop", handleDrop, false);
		});
	}

	function go() {
		initCanvas().then(function() {
			return initPalette();
		}).then(function() {
			renderCanvas();
			renderPalette();
			enableCanvas();
			enablePalette();
		})
	}
	setTimeout(go, 500);

</script>
</html>

