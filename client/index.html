<html>
<head>
<title>Hex Drag and Drop</title>
<link rel="stylesheet" type="text/css" href="css/hexx.css"/>
<style>
body {
	font-family: Tahoma, Arial;
	position: relative;
}
.heading {
	font-size: 20px;
	width: 200px;
	text-align: center;
	margin: auto;
	padding-bottom: 5px;
}
.subheading {
	font-size: 12px;
	width: 400px;
	text-align: center;
	margin: auto;
	padding-bottom: 5px;
}
</style>
</head>
<body>
<div id="heading" class="heading">Hexx Demo</div>
<div id="subheading" class="subheading">
	Drag items from the palette on the left and drop them into the grid on the right.
</div>
<div id="gridedit" class="gridedit">
	<div id="palette" class="palette"></div>
	<div class="canvasAndToolbar">
		<div id="canvas" class="canvas"></div>
		<div id="toolbar" class="toolbar"></div>
	</div>
</div>
</body>
<script src="js/lib/jquery-3.1.1.slim.min.js"></script>
<script src="js/hexx.js"></script>
<script src="js/hexxdata.js"></script>
<script>

	var config = HEXX.config;
	var data = HEXX.data;

	var originX = config.canvas.originX || 0;
	var originY = config.canvas.originY || 0;

	function withElement(id, func) {
		var ele = document.getElementById(id);
		return func(ele);
	}

	function withContext(canvas, func) {
		if (typeof canvas == "string") {
			withElement(canvas, function(canvas) {
				withContext(canvas, func);
			});
		}
		else {
			var context = canvas.getContext("2d");
			return func(context, canvas);
		}
	}

	function forEach(array, func) {
		for (var i in array) {
			func(array[i], i);
		}
	}

	function loadImage(url) {
		var promise = $.Deferred();
		var img = new Image();
		img.onload = function() { 
			promise.resolve(img);
		};
		img.onerror = function(error) {
			promise.reject(error);
		}
		img.crossOrigin = "anonymous";
		img.src = url;
		return promise;
	}

	function clearCanvas(canvas) {
		withContext(canvas, function(context, canvas) {
			context.clearRect(0, 0, canvas.width, canvas.height);
		});
	}

	function showFeedback(canvas, e) {
		clearCanvas(canvas);
		var center = HEXX.closestHex(e.offsetX, e.offsetY);
		if (center) {
			withContext(canvas, function(context) {
				HEXX.drawRegularHexagon(context, {
					radius: config.canvas.elementRadius,
					x: center.x,
					y: center.y,
					lineWidth: config.canvas.lineWidth,
					strokeStyle: config.canvas.lineStyle
				});
			});
			return center;
		}
	}

	function resetCanvasContents() {
		data.canvas.contents = data.canvas.initialContents.slice(0);
	}

	function drawGrid(canvas) {
		var cWidth = canvas.width;
		var cHeight = canvas.height;
		var conf = config.canvas;
		var radius = config.canvas.elementRadius;
		var rowSep = radius * Math.sqrt(3);
		withContext(canvas, function(context) {
			var hexDescr = {
				radius: conf.elementRadius,
				strokeStyle: conf.lineStyle || "rgba(0,0,0,0.5)",
				lineWidth: 1
			}

			for (var colIncr = -1; colIncr <= 1; colIncr += 2) {
				var column = 0;
				for (;;) {
					var pos = HEXX.centerOfHex(0, column);
					if (pos.x < -radius || pos.x > cWidth + radius) {
						break;
					}
					var x = pos.x;
					var y = pos.y - (Math.floor(pos.y / rowSep) + 1) * rowSep;

					while (y < cHeight + radius) {
						hexDescr.x = x;
						hexDescr.y = y;
						HEXX.drawRegularHexagon(context, hexDescr);
						y += rowSep;
					}
					column += colIncr;
				}
			}

		});
	}

	function renderCanvasContents() {
		withElement("drawing-canvas", function(canvas) {
			forEach(data.canvas.contents, function(cEntry) {
				drawCanvasEntry(canvas, cEntry);
			});
			if (config.canvas.showGrid) {
				drawGrid(canvas);
			}
		});
	}

	function handleDragStart(e) {
	  this.style.opacity = "0.4";
		e.dataTransfer.effectAllowed = "copy";
		e.dataTransfer.setData("text/plain", this.dataset.paletteIndex);
	}

	function handleDragOver(e) {
		e.preventDefault && e.preventDefault();
		if (showFeedback(this, e)) {
			e.dataTransfer.dropEffect = "copy";
		}
		return false;
	}

	function getUnitDistance() {
		return config.canvas.elementRadius * Math.sqrt(3);
	}

	function handleDragEnter(e) {
		showFeedback(this, e);
	}

	function handleDragLeave(e) {
		clearCanvas(this);
	}

	function handleDragEnd(e) {
	  this.style.opacity = "1";
	}

	function getDraggedPaletteEntry(e) {
		var pIndex = e.dataTransfer.getData("text/plain");
		var pEntry = data.palette.contents[pIndex];
		return pEntry;
	}

	function canvasEntryFromPaletteEntry(pEntry, center) {
		var cEntry = $.extend({}, pEntry);
		cEntry.row = center.row;
		cEntry.column = center.column;
		cEntry.radius = config.canvas.elementRadius,
		cEntry.lineWidth = config.canvas.lineWidth;
		cEntry.strokeStyle = config.canvas.lineStyle;
		return cEntry;
	}

	function drawCanvasEntry(drawingCanvas, cEntry) {
		renderHex(drawingCanvas, cEntry, config.canvas,
				HEXX.centerOfHex(cEntry.row, cEntry.column));
	}

	function handleDrop(e) {
		e.stopPropagation && e.stopPropagation();
		clearCanvas(this);  // erase drag feedback
		var center = HEXX.closestHex(e.offsetX, e.offsetY);
		if (center) {
			var cEntry = canvasEntryFromPaletteEntry(getDraggedPaletteEntry(e), center);
			data.canvas.contents.push(cEntry);
			drawCanvasEntry("drawing-canvas", cEntry);
		}
		return false;
	}

	function handleReset(e) {
		resetCanvasContents();
		withElement("drawing-canvas", function(canvas) {
			clearCanvas(canvas);
		});
		renderCanvasContents();
	}

	function handleShowHideGrid(e) {
		config.canvas.showGrid = !config.canvas.showGrid;
		clearCanvas("drawing-canvas");
		renderCanvasContents();
		this.innerHTML = (config.canvas.showGrid ? "Hide" : "Show") + " grid";
	}

	function loadImages() {
		var promise = $.Deferred();
		var imageLoadCount = 0;
		var loadsStarted = false;

		function loadAllImages(entry) {
			if (entry.image) {
				imageLoadCount += 1;
				loadImage(entry.image.url).then(function(img) {
					entry.image.obj = img;
					imageLoadCount -= 1;
					if (loadsStarted && imageLoadCount == 0) {
						promise.resolve();
					}
				})
				.catch(function(error) {
					imageLoadCount -= 1;
					if (loadsStarted && imageLoadCount == 0) {
						promise.resolve();
					}
				});
			}
		}

		forEach(data.palette.contents, loadAllImages);
		forEach(data.canvas.contents, loadAllImages);
		forEach(data.canvas.initialContents, loadAllImages);
		if (imageLoadCount == 0) {
			promise.resolve();
		}
		else {
			loadsStarted = true;
		}
		return promise;
	}

	function renderHex(canvas, entry, conf, pos) {
		var hexDescr = {
			radius: conf.elementRadius,
		}
		if (entry.image && entry.image.obj) {
			hexDescr.image = entry.image.obj;
		}
		else if (entry.fill) {
			hexDescr.fillStyle = entry.fill;
		}
		if (pos) {
			hexDescr.x = pos.x;
			hexDescr.y = pos.y;
		}
		hexDescr.strokeStyle = conf.lineStyle;
		hexDescr.lineWidth = conf.lineWidth;
		withContext(canvas, function(context) {
			HEXX.drawRegularHexagon(context, hexDescr);
		});
	}

	function renderPalette() {
		withElement("palette", function(palette) {
			forEach(data.palette.contents, function(pEntry, pIndex) {
				var container = document.createElement("div");
				var canvas = createPaletteElement(pIndex);
				pEntry.ele = canvas;
				container.appendChild(canvas);
				palette.appendChild(container);
				renderHex(canvas, pEntry, config.palette);
			});
		});
	}

	function renderCanvas() {
		withElement("canvas", function(container) {
			var drawingCanvas = document.createElement("canvas");
			drawingCanvas.id = "drawing-canvas";
			drawingCanvas.className = "drawing";
			drawingCanvas.width = config.canvas.width;
			drawingCanvas.height = config.canvas.height;
			var overlayCanvas = document.createElement("canvas");
			overlayCanvas.id = "overlay-canvas";
			overlayCanvas.className = "overlay";
			overlayCanvas.width = config.canvas.width;
			overlayCanvas.height = config.canvas.height;
			container.appendChild(drawingCanvas);
			container.appendChild(overlayCanvas);
			renderCanvasContents();
		});
	}

	function renderToolbar() {
		withElement("toolbar", function(container) {
			var resetButton = document.createElement("button");
			resetButton.innerHTML = "Reset";
			resetButton.addEventListener("click", handleReset, false);
			container.appendChild(resetButton);

			var showHideGridButton = document.createElement("button");
			showHideGridButton.innerHTML = "Show grid";
			showHideGridButton.addEventListener("click", handleShowHideGrid, false);
			container.appendChild(showHideGridButton);
		});
	}

	function enableCanvas() {
		withElement("overlay-canvas", function(canvas) {
			canvas.addEventListener("dragenter", handleDragEnter, false);
			canvas.addEventListener("dragover", handleDragOver, false);
			canvas.addEventListener("dragleave", handleDragLeave, false);
			//canvas.addEventListener("mouseover", handleMouseOver, false);
			//canvas.addEventListener("mousemove", handleMouseOver, false);
			canvas.addEventListener("drop", handleDrop, false);
		});
	}

	function createPaletteElement(pIndex) {
		var canvas = document.createElement("canvas");
		canvas.draggable = true;
		canvas.width = canvas.height = config.palette.elementRadius * 2;
		canvas.dataset.paletteIndex = pIndex;
		canvas.className = "palette";
		return canvas;
	}

	function enablePalette() {
		forEach(data.palette.contents, function(pEntry) {
			pEntry.ele.addEventListener("dragstart", handleDragStart, false);
			pEntry.ele.addEventListener("dragend", handleDragEnd, false);
		});
	}

	function go() {
		loadImages().then(function() {
			renderCanvas();
			renderPalette();
			renderToolbar();
			enableCanvas();
			enablePalette();
		})
	}
	setTimeout(go, 500);

</script>
</html>

